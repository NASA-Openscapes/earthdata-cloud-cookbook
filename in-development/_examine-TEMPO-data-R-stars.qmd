---
date: last-modified
title: Demonstration for working with TEMPO data in R using stars
---

```{r}
#| include: false
library(DT)
```

## Overview

This notebook retrieves TEMPO data, inspects characteristics of the data such as array shapes and quality flags, and then creates a visualization of total column nitrogen dioxide concentrations.

This notebook is a fork of the [original Python notebook](https://nasa.github.io/ASDC_Data_and_User_Services/TEMPO/how_to_examine_TEMPO_data_using_earthaccess.html) from the [ASDC Data and User Services Tutorials Cookbook](https://nasa.github.io/ASDC_Data_and_User_Services/). 

## Dataset Information

This notebook uses data from the [Tropospheric Emissions: Monitoring of Pollution (TEMPO)](https://asdc.larc.nasa.gov/project/TEMPO) instrument.

## Prerequisites

A free(!) account at https://www.earthdata.nasa.gov/ is needed to login and download the appropriate files.

This notebook was last tested using R Version 4.5.2 and uses these packages:

- [earthadatalogin](https://boettiger-lab.github.io/earthadatalogin/)
- [rstac](https://brazil-data-cube.github.io/rstac/)
- [stars](https://r-spatial.github.io/stars/)

### Notebook Author / Affiliation

Alexander Radkevich / Atmospheric Science Data Center (ASDC) - original Python notebook
Andy Teucher (Openscapes) - R adaptation (terra version)
Adaptation to stars package

# 1. Setup

```{r}
# Core packages for data access and manipulation
library(earthdatalogin) # Authentication with NASA Earthdata and data access
library(rstac) # Search STAC catalogs
library(stars) # Read, manipulate, and plot raster data
library(sf) # Spatial data handling

# Helper packages
library(purrr) # Functional programming tools / list manipulation
library(mirai) # Parallel downloads
library(stringr) # String manipulation
library(tigris) # State boundaries for plotting
```

# 2. Establish access to EarthData - Log in

It is best practice to store your EarthData credentials in environment variables `EARTHDATA_USER` and `EARTHDATA_PASSWORD` prior to running `earthdatalogin::edl_netrc()`. You can open your `.Renviron` file for editing using `usethis::edit_r_environ()`. Then add the following lines, replacing `your_username` and `your_password` with your actual EarthData credentials:    

```
EARTHDATA_USER=your_username
EARTHDATA_PASSWORD=your_password
```

If credentials are not already stored, `earthdatalogin::edl_netrc()` will use a default username and password.

```{r}
edl_netrc()
```

# 3. Search for TEMPO granules

First, we specify the data collection by name, a Point of Interest (POI), and a temporal range.

```{r}
short_name <- "TEMPO_NO2_L3" # collection name to search for in the EarthData
version <- "V03"

# Point of interest: NASA Langley Research Center, HamptonVA, USA
# latitude 37.1036 deg, longitude -76.3868 deg
# POI_lat <- 37.1036
# POI_lon <- -76.3868

# generic location, somewhere in the middle of the USA
POI_lat <- 38.0
POI_lon <- -96.0
date_start <- "2024-09-01T00:00:00Z"
date_end <- "2024-09-01T23:59:59Z"
```

Now we search for nitrogen dioxide ($NO_2$) data granules from TEMPO.

```{r}
dlat <- 5.0 # deg
dlon <- 6.0 # deg

bbox_results <- earthdatalogin::edl_search(
  short_name = short_name,
  version = version,
  temporal = c(date_start, date_end),
  bounding_box = c(
    POI_lon - dlon,
    POI_lat - dlat,
    POI_lon + dlon,
    POI_lat + dlat
  ), # search by bounding box
  parse_results = FALSE
)

length(bbox_results)
```

# 4. Examine and download file results

## What does a result look like?

There is a lot of metadata associated with each result. We will use `purrr::discard_at()` to remove the `polygons` and `links` elements from the first result for easier viewing.

```{r}
purrr::discard_at(bbox_results[[1]], c("polygons", "links"))
```

## Examining file names

Let's examine the file names present in the results object.

```{r}
tempo_urls <- edl_extract_urls(bbox_results)
tempo_urls
```

## Downloading granules

Here we'll download two of the files. We can use purrr's `in_parallel()` function to download multiple files in parallel. We use `mirai::daemons()` to set the number of parallel workers.

```{r}
#| eval: false
mirai::daemons(3)

files <- purrr::map_chr(
  tempo_urls[9:11],
  in_parallel(\(x) earthdatalogin::edl_download(x))
)

# Reset the number of parallel workers to 0
mirai::daemons(0)
```

# 5. Reading and inspecting the data

We downloaded the data in the previous step, however we can avoid downloading the files manually and download them only as-needed by specifying what we want with `stars::read_stars()`.

First, let's look at the metadata using GDAL functions. Because `stars` uses GDAL to read data, we can prepend the URL with `"/vsicurl/"` to read the file remotely using GDAL's [virtual file system capabilities](https://gdal.org/en/stable/user/virtual_file_systems.html#virtual-file-systems).

```{r}
nc_file <- tempo_urls[9]
nc_file

# Get subdataset information
gdal_file <- paste0("/vsicurl/", nc_file)
subdatasets <- sf::gdal_subdatasets(gdal_file)

DT::datatable(
  data.frame(
    Index = seq_along(subdatasets),
    Subdataset = subdatasets
  ),
  caption = "Available subdatasets"
)
```

We will read in the variables we are interested in: stratospheric and tropospheric NO2 vertical column densities, and quality flag.

```{r}
no2_trop <- read_stars(
  gdal_file,
  sub = "//product/vertical_column_troposphere",
  proxy = TRUE
)

no2_strat <- read_stars(
  gdal_file,
  sub = "//product/vertical_column_stratosphere",
  proxy = TRUE
)


no2_trop
no2_strat

quality_flag <- read_stars(
  gdal_file,
  sub = "//product/main_data_quality_flag",
  proxy = TRUE
)

quality_flag
```

### Let's now examine the data in a granule

```{r}
hist(no2_trop[[1]], main = "Tropospheric NO2", xlab = "molecules/cm²")
hist(no2_strat[[1]], main = "Stratospheric NO2", xlab = "molecules/cm²")
```

### Finding 'good' pixels

How many valid values are there?

NetCDF files have metadata that specify fill values for missing data. `stars` automatically converts these fill values to `NA` when reading the data. We can count the number of non-`NA` values to find how many valid pixels there are.

```{r}
sum(!is.na(no2_trop[[1]]))
sum(!is.na(no2_strat[[1]]))
```

How many pixels with high quality flag, 0, are there?

```{r}
table(quality_flag[[1]], useNA = "ifany")
```

Notice that the number of non-fill values and high-quality values are different.

**So, we need to make a mask to remove pixels that are not high quality (`quality_flag == 0`).**

```{r}
good_data_mask <- quality_flag == 0
good_data_mask
```

How many good pixels are there?

```{r}
sum(good_data_mask[[1]], na.rm = TRUE)
```

Unfortunate reality - "good" pixels may contain negative column.

```{r}
min(no2_trop[[1]][good_data_mask[[1]]], na.rm = TRUE)
min(no2_strat[[1]][good_data_mask[[1]]], na.rm = TRUE)
```

**Getting physically meaningful pixels**

We can "clamp" the negative values in `no2_trop` to zero.

```{r}
no2_trop_clamped <- no2_trop
no2_trop_clamped[[1]][no2_trop_clamped[[1]] < 0] <- 0
```

Mask the pixels (make them `NA`) where `good_data_mask` is `FALSE`.

```{r}
good_trop_no2 <- no2_trop_clamped
good_trop_no2[[1]][!good_data_mask[[1]]] <- NA

good_strat_no2 <- no2_strat
good_strat_no2[[1]][!good_data_mask[[1]]] <- NA
```

# 6. Working with the data to subset and plot

### Spatial subsetting

```{r}
POI_lat <- 38.0
POI_lon <- -96.0

dlat <- 5
dlon <- 6

# Create bounding box
bbox <- st_bbox(
  c(
    xmin = POI_lon - dlon,
    xmax = POI_lon + dlon,
    ymin = POI_lat - dlat,
    ymax = POI_lat + dlat
  ),
  crs = st_crs(4326)
)

no2_trop_cropped <- st_crop(good_trop_no2, bbox)
no2_strat_cropped <- st_crop(good_strat_no2, bbox)
```

### Plotting spatial distribution

We can use basic plotting functionality from `stars` to visualize the data. Let's first plot tropospheric and stratospheric NO2 columns separately, then plot the total column (sum of the two).

```{r}
#| warning: false
#| message: false

# Get US state boundaries and convert to sf format
states <- states(cb = TRUE, progress_bar = FALSE) |>
  st_as_sf()

# Plot tropospheric NO2
plot(
  no2_trop_cropped,
  main = "TEMPO Tropospheric NO2 col (molecules/cm²)",
  breaks = seq(0, 5e16, by = 5e15),
  key.pos = 1,
  reset = FALSE
)
plot(st_geometry(states), add = TRUE, col = NA, border = "lightgrey", lwd = 1)

# Plot stratospheric NO2
plot(
  no2_strat_cropped,
  main = "TEMPO Stratospheric NO2 col (molecules/cm²)",
  breaks = seq(0, 5e16, by = 5e15),
  key.pos = 1,
  reset = FALSE
)
plot(st_geometry(states), add = TRUE, col = NA, border = "lightgrey", lwd = 1)

# Plot total NO2 (sum of tropospheric and stratospheric)
no2_total <- no2_trop_cropped + no2_strat_cropped

plot(
  no2_total,
  main = "TEMPO Total NO2 col (molecules/cm²)",
  breaks = seq(0, 5e16, by = 5e15),
  key.pos = 1,
  reset = FALSE
)
plot(st_geometry(states), add = TRUE, col = NA, border = "lightgrey", lwd = 1)
```
